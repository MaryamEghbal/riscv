[cite_start]باسم تعالی [cite: 1]
[cite_start]دانشگاه صنعتی اصفهان [cite: 2]
[cite_start]پروژه درس معماری و سازمان کامپیوتر [cite: 3]
[cite_start]نیمسال تحصیلی ۴۰۳۲ [cite: 4]
[cite_start]استاد درس دکتر امیر خورسندی [cite: 5]
[cite_start]دستیاران آموزشی محمد مهدی اسدی، محمد رضائیان [cite: 6]

[cite_start]**مقدمه** [cite: 7]

[cite_start]هدف این پروژه طراحی و پیاده سازی یک معماری و شبیه ساز کامپیوتری برای پردازنده ای مبتنی بر معماری RISC-V است. [cite: 8] [cite_start]به طور کلی معماری RISC-V یک معماری مجموعه دستور العمل (ISA) استاندارد و باز است که بر اساس اصول طراحی سیستمهای با مجموعه دستورالعمل کاهش یافته (RISC) توسعه یافته و امروزه مبنای بسیاری از پردازنده های جدید و کارآمد است. [cite: 9, 10] [cite_start]RISC-V به دلیل ساختار ساده، قابل توسعه بودن و رایگان بودن مجوز استفاده از آن در سالهای اخیر به یکی از محبوب ترین معماریها در حوزه های آموزشی، تحقیقاتی و حتی صنعتی تبدیل شده است. [cite: 10] [cite_start]این معماری با ارائه مجموعه ای از دستورالعملهای پایه در کنار افزونه های اختیاری مانند ضرب و تقسیم (M)، اعداد اعشاری (F) و مجموعه دستورهای فشرده شده (C)، به طراحان اجازه میدهد معماری را با توجه به نیاز خود گسترش دهند. [cite: 10] [cite_start]سادگی در طراحی سخت افزار، امکان سفارشی سازی، وجود مستندات رسمی و ابزارهای متن باز از جمله مزایای کلیدی RISC-V هستند. [cite: 11] [cite_start]بنابراین ما هم یک نمونه ساده شده از آن را برای این پروژه آموزشی در نظر گرفته ایم. [cite: 11]

[cite_start]بدیهی است که با توجه به محدودیت زمانی پروژه، امکان بررسی کامل تمام قابلیتهای RISC-V وجود ندارد. [cite: 12] [cite_start]بنابراین تنها بخشی از دستورات که در این فایل تعیین شده، الزامی خواهند بود. [cite: 13] [cite_start]البته علاوه بر دستورات ضروری، بخشی نیز به صورت اختیاری و برای کسب نمره بیشتر مشخص شده اند. [cite: 14] [cite_start]البته در صورتی که دستورات بخش ضروری پروژه به طور کامل پیاده سازی نشده باشند، هیچ گونه نمره ای به بخش های امتیازی پروژه تعلق نخواهد گرفت. [cite: 15] [cite_start]هم چنین دستیاران آموزشی در کنار شما خواهند بود تا با برگزاری جلسات توجیهی، ارائه مطالب تکمیلی و پاسخ به سؤالات، روند پیشرفت پروژه را تسهیل کنند. [cite: 16]

[cite_start]**شرح کلی پروژه** [cite: 17]

[cite_start]بنابراین گامهای پروژه به سه بخش اصلی زیر تقسیم میشود. [cite: 18] [cite_start]بدیهی است که کسب امتیاز پایه پروژه مشروط به صحت عملکرد همه این بخشها خواهد بود. [cite: 19] [cite_start]البته علاوه بر امتیاز پایه، امتیازهای تشویقی هم وجود دارد که در بخشهای بعدی شرح داده خواهند شد. [cite: 20]

۱. [cite_start]**طراحی معماری مبتنی بر RISC-V** [cite: 25]
[cite_start]در مرحله نخست، شما با بهره گیری از ابزارها و دانش یک معمار سیستمهای کامپیوتری، موظف به طراحی یک معماری ساده و البته کارآمد مبتنی بر مجموعه دستورالعملهای تعیین شده RISC-V هستید. [cite: 26] [cite_start]این معماری باید شامل بلوک دیاگرام کلی، واحدهای عملیاتی، مسیر داده (Data Path) و واحد کنترل به همراه نحوه اتصال آنها باشد. [cite: 27] [cite_start]هم چنین با استفاده از زبان RTL، باید به طور دقیق مشخص کنید که به ازای هر یک از دستورالعمل های تعیین شده در هر پالس ساعت، چه ریز عملیاتهایی در معماری پیشنهادی شما انجام میشود. [cite: 28] [cite_start]تمامی جزئیات طراحی، فرضیات اتخاذ شده، نمودارهای مربوط به معماری و مسیر داده و توضیحات فنی مرتبط باید به صورت کامل مستند شده و در قالب فایلی با فرمت مناسب (PDF یا Markdown) در پوشه ی doc پروژه قرار گیرد. [cite: 29]

۲. [cite_start]**پیاده سازی اسمبلر** [cite: 30]
[cite_start]در مرحله دوم، انتظار میرود با استفاده از هر زبان برنامه نویس دلخواه، یک اسمبلر طراحی و پیاده سازی شود که یک فایل شامل کدهای اسمبلی با قالب RISC-V را به عنوان ورودی دریافت کرده و آن را به کد ماشین معادل ترجمه کند. [cite: 31] [cite_start]خروجی این فرآیند باید به صورت یک فایل باینری با پسوند bin ذخیره شود تا در مرحله ی بعد به منظور راه اندازی فرایند اجرای برنامه در سخت افزار یا شبیه ساز مورد استفاده قرار گیرد. [cite: 32, 33]

۳. [cite_start]**هسته شبیه ساز** [cite: 34]
[cite_start]در مرحله نهایی، یک نرم افزار شبیه ساز طراحی و پیاده سازی خواهد شد که به صورت مرحله به مرحله به ازای هر پالس ساعت، رفتار سخت افزار RISC-V را در اجرای ریز دستور العملها شبیه سازی میکند. [cite: 35] [cite_start]فرآیند کار این هسته به این صورت است که در ابتدا فایل باینری تولید شده در مرحله ی دوم را به عنوان ورودی دریافت کرده و محتوای آن را در بلوک حافظه ی شبیه سازی شده بارگذاری مینماید. [cite: 36] [cite_start]سپس با آغاز چرخه ی اجرای دستورالعملها، از اولین دستور تا انتها را به صورت گام به گام از طریق شبیه سازی ریز عملیاتهای مربوطه اجرا میکند و جزییات آن (محتوای ثباتها، حافظه، ورودی/خروجی و سایر اجزای سیستم) را با گرافیک مناسب به کاربر نمایش میدهد. [cite: 37] [cite_start]لازم به توجه است که با توجه به نرم افزاری بودن فرآیند شبیه سازی، باید تمهیداتی برای تقلید دقیق رفتار سخت افزار در نظر گرفته شود. [cite: 38] [cite_start]به عنوان مثال، در سخت افزار ممکن است دو ثبات بتوانند در یک پالس ساعت مقدار خود را به صورت مستقیم مبادله کنند، در حالی که در پیاده سازی نرم افزاری این عملیات باید با استفاده از مکانیزمهای واسطه انجام شود. [cite: 38, 39] [cite_start]با توجه به این که این بخش ویترین نهایی پروژه محسوب میشود، سادگی استفاده از آن برای کاربر و نیز جذابیت بصری آن از اهمیت بالایی برخوردار است. [cite: 40] [cite_start]همچنین پیاده سازی قابلیتهای تکمیلی مانند محیط توسعه کد با امکان پیشنهاد خودکار کد، ادغام با اسمبلر با قابلیت نمایش خروجی و خطاهای احتمالی موجود در کد و ارائه پیشنهاد برای رفع آنها و نیز ارائه ابزارهای دیباگ (اجرای گام به گام، تعیین نقاط توقف و ...) میتواند به افزایش امتیاز پروژه کمک کند. [cite: 41]

[cite_start]این بخش از پروژه را هم میتوانید با استفاده از هر زبان برنامه نویسی و فریمورک GUI پیاده سازی کنید. [cite: 43] [cite_start]اما بایستی داخل یک فایل ReadMe، توضیحات روند بیلد و اجرای پروژه به صورت دقیق و کامل ذکر شود. [cite: 44] [cite_start]به صورت اکید توصیه میگردد که کدهای خود را به صورت ماژولار پیاده سازی و اصول کدنویسی تمیز و خوانا را رعایت کنید. [cite: 45] [cite_start]همچنین پیشنهاد میشود از ابزارهای کنترل ورژن مثل گیت و گیت هاب برای بک آپ گرفتن از روند توسعه پروژه استفاده کنید. [cite: 45]

[cite_start]**گروه بندی** [cite: 46]

[cite_start]شما میتوانید این پروژه را در قالب گروه حداقل دو و یا حداکثر چهار نفره انجام بدهید. [cite: 47] [cite_start]البته برای گروه های چهار نفره لازم است که دستورات ممیز شناور را علاوه بر مجموعه دستورات پایه پیاده سازی کنند. [cite: 48] [cite_start]توجه داشته باشید که نمره هر شخص بر اساس میزان فعالیت در پروژه مشخص خواهد شد. [cite: 49] [cite_start]جزئیات گروه بندی ظرف حداکثر یک هفته از تاریخ اعلام پروژه تا پایان روز پنجشنبه ۱ خردادماه باید به دستیاران آموزشی درس اطلاع داده شود. [cite: 50]

[cite_start]**تحویل پروژه** [cite: 51]

[cite_start]شما تا پایان روز ۳ تیر ماه ۱۴۰۴ فرصت دارید که فایلهای مورد نظر به شرح زیر را در قالب یک فایل فشرده که به صورت CA_Project_stdNum.zip نامگذاری شده، در تکلیفی با عنوان "پروژه نهایی درس" درون سامانه ی یکتا بارگذاری کنید. [cite: 52] [cite_start]این کار باید توسط تمامی اعضای گروه به صورت مجزا انجام پذیرد. [cite: 52]

* [cite_start]تمامی فایل های کد و فایلهای وابسته مربوط به بخشهای مختلف پروژه به تفکیک داخل پوشه ای به نام src قرار گیرد. [cite: 53]
* [cite_start]خروجی اجرایی پروژه به همراه فایل نصب نیازمندیهای احتمالی در پوشه ای به نام build قرار گیرد. [cite: 54]
* [cite_start]یک فایل ReadMe شامل توضیحات متنی در رابطه با نحوه توسعه، چگونگی نصب و اجرای پروژه تهیه و ذخیره شود. [cite: 55]
* [cite_start]یک یا چند فایل در برگیرنده توضیح دقیق معماری طراحی شده به همراه توضیح مختصر و RTL هر دستور که داخل پوشه doc قرار می گیرند. [cite: 56]
* [cite_start]یک یا چند ویدیو (حداقل ۵ دقیقه و حداکثر ۱۵ دقیقه) جهت معرفی پروژه، نحوه کار و اجرای برنامه که داخل پوشه video ذخیره میشوند. [cite: 57]

[cite_start]**ارائه پروژه** [cite: 58]

[cite_start]این پروژه یک ارائه نیز خواهد داشت که جزییات آن متعاقباً اعلام خواهد گردید (به احتمال زیاد به صورت حضوری). [cite: 59]

[cite_start]**راه های ارتباطی با دستیاران آموزشی درس** [cite: 65]

[cite_start]شما میتوانید سوالات و مشکلات خود را داخل گروه تلگرامی درس مطرح کنید. [cite: 66] [cite_start]همچنین میتوانید به صورت مستقیم با دستیاران آموزشی در ارتباط باشید: [cite: 66]
* [cite_start]آقای محمد مهدی اسدی: @mm0lasady [cite: 67]
* [cite_start]آقای محمد رضاییان: @Mr_MRF [cite: 67]

[cite_start]**نکات مهم در طراحی معماری مبتنی بر RISC-V** [cite: 68]

[cite_start]همان طور که در بخش مقدمه توضیح داده شد، در مرحله ی اول پروژه لازم است یک دیاگرام کلی از معماری پیشنهادی خود ترسیم کنید. [cite: 69] [cite_start]در این بلوک دیاگرام، صرفاً نمایش کلیات مربوط به بلوکهای اصلی مانند واحد کنترل، ALU، فایل ثباتها، حافظه و مسیرهای داده و نحوه ارتباط آنها با یکدیگر کافی است. [cite: 69] [cite_start]دقت شود که معماری طراحی شده باید مبتنی بر مدل Von Neumann باشد، به این معنا که داده و دستورالعملها در یک فضای حافظه ی مشترک ذخیره میشوند. [cite: 70] [cite_start]هم چنین به منظور کاهش هزینه ها، از گذرگاه مشترک به منظور ایجاد ارتباط بین بخشهای مختلف استفاده نمایید. [cite: 70] [cite_start]برای طراحی این دیاگرام میتوانید از ابزارهای متنوعی کمک بگیرید. [cite: 71]

[cite_start]در ادامه این مرحله، برای هر دستور العمل RISC-V که توسط معماری شما پشتیبانی میشود، باید مشخص کنید که اجرای آن در هر سیکل پالس ساعت چگونه انجام میشود. [cite: 72] [cite_start]به عبارت دیگر، فازهای اجرای هر دستور (خواندن، رمزگشایی، اجرا، دسترسی به حافظه و نوشتن نتیجه) را برای معماری طراحی شده به صورت گام به گام مستند کنید. [cite: 72]

[cite_start]**نکات مهم در طراحی اسمبلر RISC-V** [cite: 73]

[cite_start]همان گونه که میدانید، اسمبلر یک برنامه است که وظیفه دارد کدی که به زبان اسمبلی (یک زبان سطح پایین، نمادین و نزدیک به سخت افزار) نوشته شده را به کد زبان ماشین (کدی در قالب صفر و یک که توسط پردازنده قابل فهم است) تبدیل کند. [cite: 74] [cite_start]در فرآیند اسمبل کردن، اسمبلر ابتدا دستورات اسمبلی را تجزیه (Parse) کرده و با توجه به جدول کدهای عملیاتی (Opcode Table) و فرمت دستورالعملهای پشتیبانی شده در سخت افزار، معادل دودویی (Binary) هر دستور را تولید میکند. [cite: 75] [cite_start]اسمبلر همچنین ممکن است خطاهای نحوی (Syntax Errors) یا معنایی (Semantic Errors) را در کد اسمبلی شناسایی و گزارش کند تا برنامه نویس آنها را اصلاح کند. [cite: 76]

[cite_start]مطابق آن چه در درس گفته شده، اسمبلرها معمولاً در دو مرحله عمل میکنند. [cite: 77] [cite_start]در ادامه خلاصه ای از کل فرایند با توضیح هر مرحله آورده شده است: [cite: 77]

۱. [cite_start]**تحلیل اولیه و ساخت جدول نمادها**: در این مرحله اسمبلر کد را به لحاظ موارد زیر تحلیل میکند: [cite: 80]
    * [cite_start]تشخیص برچسبها (Labels) و ثبت آنها در Symbol Table. [cite: 81]
    * [cite_start]شمارش اندازه ی دستورالعملها و داده ها برای تعیین موقعیت هر خط. [cite: 83]
    * [cite_start]بررسی اصول نگارش دستورات (Syntax Check) برای اطمینان از صحت ساختار دستورات. [cite: 84]

۲. [cite_start]**ترجمه و تولید کد ماشین**: در این مرحله اسمبلر از اطلاعات مرحله ی اول برای تولید کد استفاده میکند: [cite: 85]
    * [cite_start]ترجمه ی هر دستور به کد باینری معادل. [cite: 86]
    * [cite_start]جایگزینی برچسبها با آدرس واقعی با استفاده از Symbol Table. [cite: 87]
    * [cite_start]ساخت فایل خروجی باینری با پسوند bin. [cite: 88]

[cite_start]توجه داشته باشید که حتماً باید در داخل فایل README توضیح مختصری درباره روند عملکرد اسمبلر و مراحل آن ارائه دهید. [cite: 89] [cite_start]این توضیحات باید شامل مراحل مختلف فرآیند اسمبل کردن از جمله نحوه تحلیل دستورات، تبدیل به کد باینری و تولید فایل خروجی باشد. [cite: 89]

[cite_start]**نکات مهم در طراحی شبیه ساز** [cite: 90]

[cite_start]در مرحله آخر پروژه لازم است یک نرم افزار شبیه ساز طراحی و پیاده سازی شود که بتواند با دریافت یک فایل باینری با پسوند bin، رفتار سخت افزار را در پردازش دستورات شبیه سازی کند. [cite: 91] [cite_start]برای شروع، هنگامی که شبیه ساز راه اندازی میشود، مقدار تمامی ثباتها صفر است و مقدار ثبات برنامه شمار (PC) به آدرس 0x1000 تنظیم میشود. [cite: 92] [cite_start]در ادامه، شبیه ساز باید فازهای مختلف اجرای هر دستور را به طور گام به گام شبیه سازی کند. [cite: 93] [cite_start]این فازها شامل مراحل زیر خواهند بود: [cite: 94]

1.  [cite_start]**واکشی دستور**: بارگذاری دستور از آدرس تعیین شده درون حافظه. [cite: 95]
2.  [cite_start]**رمزگشایی**: تجزیه دستور برای استخراج اجزای مختلف آن شامل کد دستور، عملوندها و... [cite: 95]
3.  [cite_start]**اجرا**: انجام عملیات محاسباتی یا منطقی به صورت پالس به پالس. [cite: 95]
4.  [cite_start]**دسترسی به حافظه**: اگر دستور نیاز به دسترسی به حافظه (خواندن یا نوشتن) داشته باشد، این مرحله انجام میشود. [cite: 96]
5.  [cite_start]**نوشتن نتیجه**: نوشتن نتیجه ی عملیات در ثباتها یا حافظه. [cite: 97]

[cite_start]در طول زمان شبیه سازی، باید همواره وضعیت سیستم شامل ثباتها، حافظه و وضعیت پردازنده در هر مرحله نمایش داده شود. [cite: 98] [cite_start]برای کنترل زمان در شبیه ساز، حداقل باید دو حالت پیاده سازی شود: حالت اول به صورت توقف ناپذیر که کل اجرا از ابتدا تا انتها با سرعت تعیین شده توسط کاربر پیش میرود، اما در حالت دوم با هر بار فشردن یک کلید مخصوص توسط کاربر، تعداد مشخصی پالس ساعت تولید و اجرا به همان اندازه پیش خواهد رفت. [cite: 99]

[cite_start]**کلیات معماری RISC-V** [cite: 132]

[cite_start]معماری RISC-V دارای طراحی مدولاری است که در نسخه حداقلی از بخشهای پایه تشکیل شده و در نسخه های کامل تر، افزونه های اختیاری به آن اضافه میشود. [cite: 133] [cite_start]بر این اساس، در این بخش مروری بر نسخه پایه و مجموعه دستورات پشتیبانی شده توسط آن که در انجام این پروژه ضروری هستند، خواهیم داشت. [cite: 133]

[cite_start]**ثبات های پایه** [cite: 134]

[cite_start]معماری RISC-V شامل ۳۲ ثبات پایه مندرج در جدول زیر است: [cite: 135]

| Register | ABI Name | Description | Saver |
| :--- | :--- | :--- | :--- |
| x0 | zero | Zero constant | |
| x1 | ra | Return address | Caller |
| x2 | sp | Stack pointer | Callee |
| x3 | gp | Global pointer | |
| x4 | tp | Thread pointer | |
| x5-x7 | t0-t2 | Temporaries | Caller |
| x8 | s0 / fp | Saved / frame pointer | Callee |
| x9 | s1 | Saved register | Callee |
| x10-x11 | a0-a1 | Fn args/return values | Caller |
| x12-x17 | a2-a7 | Fn args | Caller |
| x18-x27 | s2-s11 | Saved registers | Callee |
| x28-x31 | t3-t6 | Temporaries | Caller |

[cite_start]**دستورالعمل های پایه محاسبات اعداد صحیح (RV32I)** [cite: 160]

[cite_start]این مجموعه شامل دستوراتی برای انجام عملیات محاسباتی پایه مانند جمع، تفریق و شیفت، عملیات بارگذاری و ذخیره سازی داده در حافظه، دستورالعملهای پرش و انشعاب و برخی عملیات منطقی نظیر AND, OR و XOR بر روی اعداد صحیح میباشد. [cite: 161] [cite_start]در ادامه، دستورات پایه ای که پیاده سازی آنها برای این پروژه الزامی هستند را بررسی خواهیم کرد: [cite: 171]

* [cite_start]`add`: جمع دو مقدار موجود در ثباتهای rs1 و rs2 و ذخیره نتیجه در ثبات rd. [cite: 173]
* [cite_start]`sub`: کم کردن مقدار ثبات rs2 از مقدار ثبات rs1 و ذخیره نتیجه در ثبات rd. [cite: 176]
* [cite_start]`xor`: اجرای عملگر منطقی XOR بیت به بیت بین مقادیر rs1 و rs2 و ذخیره نتیجه در rd. [cite: 179]
* [cite_start]`or`: اجرای عملگر منطقی OR بیت به بیت بین مقادیر rs1 و rs2 و ذخیره نتیجه در rd. [cite: 182]
* [cite_start]`and`: اجرای عملگر منطقی AND بیت به بیت بین rs1 و rs2 و قرار دادن نتیجه در rd. [cite: 185]
* [cite_start]`sll`: شیفت منطقی به چپ مقدار rs1 به اندازه مشخص شده توسط ۵ بیت کم ارزش rs2 که نتیجه در rd ذخیره میشود. [cite: 190, 191]
* [cite_start]`srl`: شیفت منطقی به راست مقدار rs1 به اندازه مشخص شده توسط ۵ بیت کم ارزش rs2 و ذخیره نتیجه در rd. [cite: 194, 195]
* [cite_start]`sra`: شیفت حسابی به راست مقدار rs1 به اندازه مقدار مشخص شده توسط ۵ بیت کم ارزش rs2 با حفظ بیت علامت که نتیجه در rd قرار میگیرد. [cite: 198]
* [cite_start]`slt`: اگر مقدار عدد علامتدار درون rs1 از مقدار عدد علامتدار درون rs2 کمتر باشد، مقدار ۱ و در غیر این صورت مقدار ۰ در rd قرار میگیرد. [cite: 201, 202]
* [cite_start]`sltu`: عملیاتی مشابه slt را به صورت بدون علامت (unsigned) انجام میدهد. [cite: 209]
* [cite_start]`addi`: جمع مقدار ثبات rs1 با یک عدد ثابت بلافصل (Immediate) و ذخیره نتیجه در ثبات rd. [cite: 212]
* [cite_start]`lh`: ۱۶ بیت کم ارزش محتوای حافظه با آدرس rs1 + imm را به صورت sign-extended شده درون ثبات rd بارگذاری میکند. [cite: 218, 219]
* [cite_start]`lw`: محتوای ۳۲ بیتی درون حافظه با آدرس تعیین شده را در rd بارگذاری میکند. [cite: 222]
* [cite_start]`sh`: مقدار ۱۶ بیت کم ارزش درون rs2 را در حافظه به آدرس [rs1 + imm] ذخیره میکند. [cite: 227]
* [cite_start]`sw`: مقدار ۳۲ بیتی درون rs2 را درون حافظه به آدرس [rs1 + imm] ذخیره میکند. [cite: 230]
* [cite_start]`beq`: اگر رابطه rs1 == rs2 بین محتوای دو ثبات برقرار بود، ادامه اجرای دستورات به آدرس جدید PC + imm منتقل خواهد شد. [cite: 233]
* [cite_start]`bne`: اگر rs1 != rs2 بود، به PC + imm پرش کن. [cite: 238]
* [cite_start]`blt`: اگر rs1 < rs2 بود، پرش انجام شود (اعداد به صورت علامتدار). [cite: 243]
* [cite_start]`bge`: اگر rs1 >= rs2، پرش انجام شود (اعداد به صورت علامتدار). [cite: 246]
* [cite_start]`bltu`: اگر rs1 < rs2، پرش انجام شود (اعداد به صورت بدون علامت). [cite: 249, 250]
* [cite_start]`bgeu`: اگر rs1 >= rs2، پرش انجام شود (اعداد به صورت بدون علامت). [cite: 253, 254]
* [cite_start]`jal`: rd = PC + 4 میشود و سپس ادامه اجرا به آدرس PC + imm منتقل میگردد. [cite: 260]
* [cite_start]`jalr`: مشابه دستور قبلی است با این تفاوت که پرش به آدرس rs1 + imm انجام خواهد شد (آدرس دهی غیر مستقیم). [cite: 265, 266]
* [cite_start]`lui`: بارگذاری مقدار بلافصل ۲۰ بیتی در بخش پرارزش (rd = imm << 12). [cite: 269]
* [cite_start]`auipc`: بارگذاری به صورت rd = PC + (imm << 12) که برای آدرس دهی نسبی استفاده میشود. [cite: 272]

[cite_start]**دستورالعمل های ضرب (RV32M)** [cite: 280]

* [cite_start]`mul`: ضرب اعداد ۳۲ بیتی علامتدار به صورت rs1 * rs2 که فقط ۳۲ بیت پایین (بیتهای [31:0]) ذخیره میشود. [cite: 286, 287]
* [cite_start]`mulh`: مقدار ۳۲ بیت پرارزش حاصل از ضرب دو عدد ۳۲ بیتی علامتدار (بیتهای) را بر می گرداند. [cite: 290, 291]
* [cite_start]`div`: تقسیم صحیح علامتدار را به صورت rd = rs1 / rs2 انجام میدهد. [cite: 295]
* [cite_start]`rem`: باقیمانده تقسیم علامتدار را به صورت rd = rs1 % rs2 ذخیره می نماید. [cite: 303]

[cite_start]**دستورات محاسبات ممیز شناور (ضروری برای گروه های چهارنفره)** [cite: 307]

[cite_start]گروه های چهار نفره علاوه بر دستورات مشخص شده، موظفند که طراحی و پیاده سازی دستورات مرتبط با ممیز شناور را نیز انجام دهند. [cite: 308]

[cite_start]**نکاتی در رابطه با زبان اسمبلی RISC-V** [cite: 348]

[cite_start]**فرمت عدد نویسی:** [cite: 350]
* [cite_start]**Decimal**: فرمت پیش فرض. [cite: 352]
* [cite_start]**Hexadecimal**: با پیشوند 0x شروع میشود. [cite: 352]
* [cite_start]**Binary**: با پیشوند 0b شروع میشود. [cite: 353]

[cite_start]**دستورات راهنما (Directives):** [cite: 363, 364]
* [cite_start]`.org`: تنظیم موقعیت فعلی آدرس دهی. [cite: 368]
* [cite_start]`.word`: قراردادن یک مقدار ۳۲ بیتی در حافظه. [cite: 370]
* [cite_start]`.half`: قراردادن یک مقدار ۱۶ بیتی در حافظه. [cite: 371]
* [cite_start]`.byte`: قراردادن یک مقدار ۸ بیتی در حافظه. [cite: 371]
* [cite_start]`.align n`: تراز کردن آدرس حافظه به مضرب 2^n. [cite: 372]

[cite_start]**شبه دستورات (Pseudo-Instructions):** [cite: 386]
* [cite_start]`nop`: هیچ کاری انجام نمیدهد (معادل `addi x0, x0, 0`). [cite: 388, 392]
* [cite_start]`li rd, imm`: یک مقدار بلافصل را درون ثبات مقصد قرار میدهد. [cite: 393]
* [cite_start]`mv rd, rs`: مقدار ثبات rs را درون ثبات rd کپی میکند (معادل `addi rd, rs, 0`). [cite: 396, 397]
* [cite_start]`not rd, rs`: نقیض بیت به بیت (معادل `xori rd, rs, -1`). [cite: 398, 399]
* [cite_start]`neg rd, rs`: مکمل دو (معادل `sub rd, x0, rs`). [cite: 400, 401]

[cite_start]**اندازه حافظه** [cite: 409]

[cite_start]برای این پروژه، پیشنهاد میشود که محدوده ی آدرس دهی مورد استفاده به ۶۴ کیلو بایت محدود شود (از 0x0 تا 0xFFFF). [cite: 411] [cite_start]بنابراین، چنان چه به آدرسهای خارج از این محدوده دسترسی صورت پذیرد، اسمبلر و شبیه ساز باید با صدور خطای مناسب به برنامه نویس هشدار دهند. [cite: 412] [cite_start]همچنین، فرض بر آن است که مقدار اولیه ی ثبات شمارنده برنامه (PC) برابر با آدرس 0x1000 است. [cite: 413, 415]